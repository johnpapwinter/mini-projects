package gr.aueb.cf.testbed.miniProjectsEaster;

import java.util.Scanner;

/**
 * Έστω ένας πίνακας n ακεραίων. Τότε ο maximum sub subarray ο είναι ο συνεχόμενος
 * υποπίνακας (contiguous subarray - δυνητικά κενό) με το μεγαλύτερο άθροισμα.
 * Σχεδιάστε έναν γραμμικό αλγόριθμο (με πολυπλοκότητα O(n)) για να επιλύσετε τα
 * παραπάνω πρόβλημα. Για παράδειγμα, αν έχουμε τον πίνακα {−2, 1, −3, 4, −1, 2, 1,
 * −5, 4} τότε ο συνεχόμενος υποπίνακας με το μέγιστο άθροισμα είναι ο {4, −1, 2, 1},
 * του οποίου το άθροισμα είναι 6.
 * Δώστε μια λύση τριών μερών της ακόλουθης μορφής:
 * (α) Περιγράψτε (με λόγια και σχήματα) ξεκάθαρα τον αλγόριθμό σας.
 * (β) Γράψτε τον κώδικα σε Java.
 * (γ) Δείξτε ότι η πολυπλοκότητα χρόνου είναι O(n)
 * Hint. Χρησιμοποιήστε δυναμικό προγραμματισμό (βασική αρχή στον δυναμικό
 * προγραμματισμό είναι όταν υπολογίζουμε κάτι να το αποθηκεύουμε, ώστε αν το
 * ξαναχρειαστούμε να μην το ξαναυπολογίζουμε). Μην υπολογίζετε ξανά και ξανά το
 * άθροισμα για όλους τους δυνατούς υποπίνακες. Αν βρείτε ένα τοπικό μέγιστο (το
 * μέγιστο από τη θέση 0 μέχρι μία θέση i του πίνακα arr) τότε για τη θέση i + 1 το
 * μέγιστο θα είναι το max(τοπικό μέγιστο (i – 1) + arr[i], arr[i]).
 * Παρατηρήστε στον παρακάτω πίνακα ότι αν έχουμε υπολογίσει το τοπικό μέγιστο για
 * τη θέση arr[4] όπου το τοπικό μέγιστο είναι το 3, τότε για την επόμενη θέση του
 * πίνακα, τη θέση arr[5], το τοπικό μέγιστο είναι max(local-max(i – 1) + arr[i], i), δηλαδή max(3 + 2, 2) = 5.
 * Ο πιο εύκολος τρόπος να λυθεί το πρόβλημα είναι ο επαναληπτικός με μία for.
 * Για την αναδρομική λύση μπορούμε ξεκινώντας από το τελευταίο στοιχείο (n-1)
 * να υπολογίσουμε αναδρομικά τα local maxima. Το local maximum του arr[0]
 * είναι η τιμή του arr[0]. Στο παράδειγμα είναι arr[0] = -2. Μπορούμε επίσης να έχουμε
 * μία μεταβλητή static int σε επίπεδο κλάσης που να είναι το globalMaximum
 * και να ενημερώνεται από όλες τις μεθόδους στο βάθος της αναδρομής,
 * όταν το localMaximum είναι μεγαλύτερο από το globalMaximum.
 */


/**
 * Ελέγχουμε τους υποπίνακες σταδιακά υπολογίζοντας το άθροισμά τους και συγκρίνοντάς το
 * με το επόμενο στοιχείο του πίνακα. Σε περίπτωση που το άθροισμα του υποπίνακα είναι μικρότερο
 * από το άθροισμά του με του επομένου στοιχείου (n + next < next) τότε αυτό σημαίνει ότι το next
 * είναι μεγαλύτερο και μπορεί να πάρει τη θέση του μεγαλύτερου αθροίσματος. Ταυτόχρονα, συγκρίνουμε
 * το max με το γενικό max και το αντικαθιστούμε σε περίπτωση που είναι μεγαλύτερο.
 */
public class Project06Subarrays {
    public static void main(String[] args) {
        int[] array = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        int localMax = array[0];
        int globalMax = array[0];

        for (int i = 0; i < array.length; i++) {
            if (localMax + array[i] < array[i]) {
                localMax = array[i];
                if (localMax > globalMax) {
                    globalMax = localMax;
                }
            } else {
                localMax = localMax + array[i];
                if (localMax > globalMax) {
                    globalMax = localMax;
                }
            }
        }

        System.out.println("The greatest continuous sum is " + globalMax);


    }
}
